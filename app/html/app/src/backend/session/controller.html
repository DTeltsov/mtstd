<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>app.src.backend.session.controller API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.src.backend.session.controller</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PyQt5.QtCore import QObject, pyqtProperty, pyqtSignal, QSettings
from qasync import asyncSlot

from app.src.backend.database import Database
from app.src.backend.integration import PropertyMeta
from app.src.backend.library import Library
from app.src.backend.player import Player
from app.src.backend.user import User


class Session(QObject, metaclass=PropertyMeta):
    &#34;&#34;&#34;
    The `Session` class manages user sessions, login/logout, and library setup.

    Attributes:
    - signalError (pyqtSignal): Signal emitted in case of an error with the error message as the argument.
    - signalStartSession (pyqtSignal): Signal emitted when starting a new session.
    - user (pyqtProperty): Property representing the user, with read-only access.
    - library (pyqtProperty): Property representing the library, with read-only access.

    Methods:
    - __init__(): Constructor to initialize the `Session` object.
    - _connect_signals(): Connects signals between the user and the session.
    - login(login: str, password: str, token: str = &#39;&#39;) -&gt; None: Asynchronously logs in the user.
    - logout() -&gt; None: Asynchronously logs out the user.
    - setup_library(songs: list) -&gt; None: Asynchronously sets up the library with the given songs.
    - memorize_session() -&gt; None: Memorizes the current session by storing the token in settings.
    - check_q_settings() -&gt; None: Checks the settings for an existing token and logs in if found.
    &#34;&#34;&#34;

    signalError = pyqtSignal(str)
    signalStartSession = pyqtSignal()
    user = pyqtProperty(QObject, fget=lambda self: self._user, constant=True)
    library = pyqtProperty(QObject, fget=lambda self: self._library, constant=True)

    def __init__(self):
        &#34;&#34;&#34;
        Initializes a new `Session` object.

        This constructor creates instances of the User, Player, Database, and Library classes.
        It also connects signals and performs the initial check for stored settings.
        &#34;&#34;&#34;
        super().__init__()
        self._user = User()
        self.player = Player()
        self.database = Database()
        self._library = Library()
        self.q_settings = QSettings()
        self._connect_signals()
        self.check_q_settings()

    def _connect_signals(self):
        &#34;&#34;&#34;
        Connects signals between the user and the session.

        Signals Connected:
        - signalSuccessLogin: Connected to the setup_library method.
        - signalError: Connected to the signalError signal of the session.
        &#34;&#34;&#34;
        self._user.signalSuccessLogin.connect(self.setup_library)
        self._user.signalError.connect(self.signalError)

    @asyncSlot(str, str, str)
    async def login(self, login, password, token=&#39;&#39;):
        &#34;&#34;&#34;
        Asynchronously logs in the user.

        Parameters:
        - login (str): The user&#39;s login.
        - password (str): The user&#39;s password.
        - token (str): Optional token for authentication.

        Returns:
        None
        &#34;&#34;&#34;
        await self.user.login(login, password, self.database.login, token)

    @asyncSlot()
    async def logout(self):
        &#34;&#34;&#34;
        Asynchronously logs out the user.

        Returns:
        None
        &#34;&#34;&#34;
        self.user.logout()
        self.database.reset()
        self.q_settings.remove(&#39;token&#39;)
        self.q_settings.sync()

    @asyncSlot(list)
    async def setup_library(self, songs):
        &#34;&#34;&#34;
        Asynchronously sets up the library with the given songs.

        Parameters:
        - songs (list): List of songs to set up the library.

        Returns:
        None
        &#34;&#34;&#34;
        self.memorize_session()
        self.library.setup(songs)
        self.signalStartSession.emit()

    def memorize_session(self):
        &#34;&#34;&#34;
        Memorizes the current session by storing the token in settings.

        Returns:
        None
        &#34;&#34;&#34;
        self.q_settings.setValue(&#39;token&#39;, self.database.token)
        self.q_settings.sync()

    def check_q_settings(self):
        &#34;&#34;&#34;
        Checks the settings for an existing token and logs in if found.

        Returns:
        None
        &#34;&#34;&#34;
        if self.q_settings.contains(&#39;token&#39;):
            self.login(&#39;&#39;, &#39;&#39;, self.q_settings.value(&#39;token&#39;, &#39;&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.src.backend.session.controller.Session"><code class="flex name class">
<span>class <span class="ident">Session</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="app.src.backend.session.controller.Session" href="#app.src.backend.session.controller.Session">Session</a></code> class manages user sessions, login/logout, and library setup.</p>
<p>Attributes:
- signalError (pyqtSignal): Signal emitted in case of an error with the error message as the argument.
- signalStartSession (pyqtSignal): Signal emitted when starting a new session.
- user (pyqtProperty): Property representing the user, with read-only access.
- library (pyqtProperty): Property representing the library, with read-only access.</p>
<p>Methods:
- <strong>init</strong>(): Constructor to initialize the <code><a title="app.src.backend.session.controller.Session" href="#app.src.backend.session.controller.Session">Session</a></code> object.
- _connect_signals(): Connects signals between the user and the session.
- login(login: str, password: str, token: str = '') -&gt; None: Asynchronously logs in the user.
- logout() -&gt; None: Asynchronously logs out the user.
- setup_library(songs: list) -&gt; None: Asynchronously sets up the library with the given songs.
- memorize_session() -&gt; None: Memorizes the current session by storing the token in settings.
- check_q_settings() -&gt; None: Checks the settings for an existing token and logs in if found.</p>
<p>Initializes a new <code><a title="app.src.backend.session.controller.Session" href="#app.src.backend.session.controller.Session">Session</a></code> object.</p>
<p>This constructor creates instances of the User, Player, Database, and Library classes.
It also connects signals and performs the initial check for stored settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Session(QObject, metaclass=PropertyMeta):
    &#34;&#34;&#34;
    The `Session` class manages user sessions, login/logout, and library setup.

    Attributes:
    - signalError (pyqtSignal): Signal emitted in case of an error with the error message as the argument.
    - signalStartSession (pyqtSignal): Signal emitted when starting a new session.
    - user (pyqtProperty): Property representing the user, with read-only access.
    - library (pyqtProperty): Property representing the library, with read-only access.

    Methods:
    - __init__(): Constructor to initialize the `Session` object.
    - _connect_signals(): Connects signals between the user and the session.
    - login(login: str, password: str, token: str = &#39;&#39;) -&gt; None: Asynchronously logs in the user.
    - logout() -&gt; None: Asynchronously logs out the user.
    - setup_library(songs: list) -&gt; None: Asynchronously sets up the library with the given songs.
    - memorize_session() -&gt; None: Memorizes the current session by storing the token in settings.
    - check_q_settings() -&gt; None: Checks the settings for an existing token and logs in if found.
    &#34;&#34;&#34;

    signalError = pyqtSignal(str)
    signalStartSession = pyqtSignal()
    user = pyqtProperty(QObject, fget=lambda self: self._user, constant=True)
    library = pyqtProperty(QObject, fget=lambda self: self._library, constant=True)

    def __init__(self):
        &#34;&#34;&#34;
        Initializes a new `Session` object.

        This constructor creates instances of the User, Player, Database, and Library classes.
        It also connects signals and performs the initial check for stored settings.
        &#34;&#34;&#34;
        super().__init__()
        self._user = User()
        self.player = Player()
        self.database = Database()
        self._library = Library()
        self.q_settings = QSettings()
        self._connect_signals()
        self.check_q_settings()

    def _connect_signals(self):
        &#34;&#34;&#34;
        Connects signals between the user and the session.

        Signals Connected:
        - signalSuccessLogin: Connected to the setup_library method.
        - signalError: Connected to the signalError signal of the session.
        &#34;&#34;&#34;
        self._user.signalSuccessLogin.connect(self.setup_library)
        self._user.signalError.connect(self.signalError)

    @asyncSlot(str, str, str)
    async def login(self, login, password, token=&#39;&#39;):
        &#34;&#34;&#34;
        Asynchronously logs in the user.

        Parameters:
        - login (str): The user&#39;s login.
        - password (str): The user&#39;s password.
        - token (str): Optional token for authentication.

        Returns:
        None
        &#34;&#34;&#34;
        await self.user.login(login, password, self.database.login, token)

    @asyncSlot()
    async def logout(self):
        &#34;&#34;&#34;
        Asynchronously logs out the user.

        Returns:
        None
        &#34;&#34;&#34;
        self.user.logout()
        self.database.reset()
        self.q_settings.remove(&#39;token&#39;)
        self.q_settings.sync()

    @asyncSlot(list)
    async def setup_library(self, songs):
        &#34;&#34;&#34;
        Asynchronously sets up the library with the given songs.

        Parameters:
        - songs (list): List of songs to set up the library.

        Returns:
        None
        &#34;&#34;&#34;
        self.memorize_session()
        self.library.setup(songs)
        self.signalStartSession.emit()

    def memorize_session(self):
        &#34;&#34;&#34;
        Memorizes the current session by storing the token in settings.

        Returns:
        None
        &#34;&#34;&#34;
        self.q_settings.setValue(&#39;token&#39;, self.database.token)
        self.q_settings.sync()

    def check_q_settings(self):
        &#34;&#34;&#34;
        Checks the settings for an existing token and logs in if found.

        Returns:
        None
        &#34;&#34;&#34;
        if self.q_settings.contains(&#39;token&#39;):
            self.login(&#39;&#39;, &#39;&#39;, self.q_settings.value(&#39;token&#39;, &#39;&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="app.src.backend.session.controller.Session.library"><code class="name">var <span class="ident">library</span></code></dt>
<dd>
<div class="desc"><p>pyqtProperty(type, fget=None, fset=None, freset=None, fdel=None, doc=None,
designable=True, scriptable=True, stored=True, user=False,
constant=False, final=False, notify=None,
revision=0) -&gt; property attribute</p>
<p>type is the type of the property.
It is either a type object or a string
that is the name of a C++ type.
freset is a function for resetting an attribute to its default value.
designable sets the DESIGNABLE flag (the default is True for writable
properties and False otherwise).
scriptable sets the SCRIPTABLE flag.
stored sets the STORED flag.
user sets the USER flag.
constant sets the CONSTANT flag.
final sets the FINAL flag.
notify is the NOTIFY signal.
revision is the REVISION.
The other parameters are the same as those required by the standard Python
property type.
Properties defined using pyqtProperty behave as both Python
and Qt properties.
Decorators can be used to define new properties or to modify existing ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">library = pyqtProperty(QObject, fget=lambda self: self._library, constant=True)</code></pre>
</details>
</dd>
<dt id="app.src.backend.session.controller.Session.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"><p>pyqtProperty(type, fget=None, fset=None, freset=None, fdel=None, doc=None,
designable=True, scriptable=True, stored=True, user=False,
constant=False, final=False, notify=None,
revision=0) -&gt; property attribute</p>
<p>type is the type of the property.
It is either a type object or a string
that is the name of a C++ type.
freset is a function for resetting an attribute to its default value.
designable sets the DESIGNABLE flag (the default is True for writable
properties and False otherwise).
scriptable sets the SCRIPTABLE flag.
stored sets the STORED flag.
user sets the USER flag.
constant sets the CONSTANT flag.
final sets the FINAL flag.
notify is the NOTIFY signal.
revision is the REVISION.
The other parameters are the same as those required by the standard Python
property type.
Properties defined using pyqtProperty behave as both Python
and Qt properties.
Decorators can be used to define new properties or to modify existing ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">user = pyqtProperty(QObject, fget=lambda self: self._user, constant=True)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="app.src.backend.session.controller.Session.check_q_settings"><code class="name flex">
<span>def <span class="ident">check_q_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the settings for an existing token and logs in if found.</p>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_q_settings(self):
    &#34;&#34;&#34;
    Checks the settings for an existing token and logs in if found.

    Returns:
    None
    &#34;&#34;&#34;
    if self.q_settings.contains(&#39;token&#39;):
        self.login(&#39;&#39;, &#39;&#39;, self.q_settings.value(&#39;token&#39;, &#39;&#39;))</code></pre>
</details>
</dd>
<dt id="app.src.backend.session.controller.Session.login"><code class="name flex">
<span>async def <span class="ident">login</span></span>(<span>self, login, password, token='')</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously logs in the user.</p>
<p>Parameters:
- login (str): The user's login.
- password (str): The user's password.
- token (str): Optional token for authentication.</p>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@asyncSlot(str, str, str)
async def login(self, login, password, token=&#39;&#39;):
    &#34;&#34;&#34;
    Asynchronously logs in the user.

    Parameters:
    - login (str): The user&#39;s login.
    - password (str): The user&#39;s password.
    - token (str): Optional token for authentication.

    Returns:
    None
    &#34;&#34;&#34;
    await self.user.login(login, password, self.database.login, token)</code></pre>
</details>
</dd>
<dt id="app.src.backend.session.controller.Session.logout"><code class="name flex">
<span>async def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously logs out the user.</p>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@asyncSlot()
async def logout(self):
    &#34;&#34;&#34;
    Asynchronously logs out the user.

    Returns:
    None
    &#34;&#34;&#34;
    self.user.logout()
    self.database.reset()
    self.q_settings.remove(&#39;token&#39;)
    self.q_settings.sync()</code></pre>
</details>
</dd>
<dt id="app.src.backend.session.controller.Session.memorize_session"><code class="name flex">
<span>def <span class="ident">memorize_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Memorizes the current session by storing the token in settings.</p>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memorize_session(self):
    &#34;&#34;&#34;
    Memorizes the current session by storing the token in settings.

    Returns:
    None
    &#34;&#34;&#34;
    self.q_settings.setValue(&#39;token&#39;, self.database.token)
    self.q_settings.sync()</code></pre>
</details>
</dd>
<dt id="app.src.backend.session.controller.Session.setup_library"><code class="name flex">
<span>async def <span class="ident">setup_library</span></span>(<span>self, songs)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously sets up the library with the given songs.</p>
<p>Parameters:
- songs (list): List of songs to set up the library.</p>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@asyncSlot(list)
async def setup_library(self, songs):
    &#34;&#34;&#34;
    Asynchronously sets up the library with the given songs.

    Parameters:
    - songs (list): List of songs to set up the library.

    Returns:
    None
    &#34;&#34;&#34;
    self.memorize_session()
    self.library.setup(songs)
    self.signalStartSession.emit()</code></pre>
</details>
</dd>
<dt id="app.src.backend.session.controller.Session.signalError"><code class="name flex">
<span>def <span class="ident">signalError</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="app.src.backend.session.controller.Session.signalStartSession"><code class="name flex">
<span>def <span class="ident">signalStartSession</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.src.backend.session" href="index.html">app.src.backend.session</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.src.backend.session.controller.Session" href="#app.src.backend.session.controller.Session">Session</a></code></h4>
<ul class="two-column">
<li><code><a title="app.src.backend.session.controller.Session.check_q_settings" href="#app.src.backend.session.controller.Session.check_q_settings">check_q_settings</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.library" href="#app.src.backend.session.controller.Session.library">library</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.login" href="#app.src.backend.session.controller.Session.login">login</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.logout" href="#app.src.backend.session.controller.Session.logout">logout</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.memorize_session" href="#app.src.backend.session.controller.Session.memorize_session">memorize_session</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.setup_library" href="#app.src.backend.session.controller.Session.setup_library">setup_library</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.signalError" href="#app.src.backend.session.controller.Session.signalError">signalError</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.signalStartSession" href="#app.src.backend.session.controller.Session.signalStartSession">signalStartSession</a></code></li>
<li><code><a title="app.src.backend.session.controller.Session.user" href="#app.src.backend.session.controller.Session.user">user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>